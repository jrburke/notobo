{
  "name": "voxel-physical",
  "version": "0.0.10",
  "description": "create objects that have aabbs and respond to accel and vel updates",
  "main": "index.js",
  "scripts": {
    "test": "echo \"Error: no test specified\" && exit 1"
  },
  "repository": {
    "type": "git",
    "url": "git://github.com/chrisdickinson/voxel-physical.git"
  },
  "keywords": [
    "voxeljs",
    "physics"
  ],
  "author": {
    "name": "Chris Dickinson",
    "email": "chris@neversaw.us"
  },
  "license": "MIT",
  "gitHead": "1b2a372bce5fb9fd460e231c0cea8fcc5d6e2352",
  "dependencies": {
    "three": "0.X.X",
    "aabb-3d": "0.0.X"
  },
  "readme": "# voxel-physical\n\ncreate voxel-js objects that are affected by physics!\n\n```javascript\n// typical usage:\nvar game = require('voxel-engine')({})\n  , object = new THREE.Mesh()\n\nvar physics = game.makePhysical(object)\ngame.addItem(physics)\ngame.scene.add(object)\n\n// direct usage:\nvar physical = require('voxel-physical')\n\nvar physics = physical(\n    object\n  , game.potentialCollisionSet()    // list of objects providing a `collide(otherObject, otherBBox, desiredVector, resting map)\n \n  , new THREE.Vector3(10, 10, 10)   // how big am i? w/h/d\n  , new THREE.Vector3(30, 5.6, 30)  // what's my terminal velocity?\n) \n\ngame.addItem(physics)\ngame.scene.add(object) \n\n```\n\n## API\n\n#### physics.aabb() -> aabb-3d instance\n\nCreate a bounding box for the physics.\n\n#### physics.subjectTo(vec3 force) -> physics\n\nState that the object is subject to this force every frame -- i.e., gravity.\n\n#### physics.avatar -> THREE.Mesh / THREE.Object3D\n\nThe target of the physics. All physics are applied in this object's world space (so,\nif you have a player, they're comprised of `yaw`, `pitch`, and `roll` Object3D instances along with\nmeshes -- `roll` and `pitch` are contained by `yaw`, so `yaw` is the outermost object in this\ncase.)\n\n#### physics.resting -> {x: [-1, 0, 1], y: [-1, 0, 1], z: [-1, 0, 1]}\n#### physics.atRestX() -> [-1, 0, 1]\n#### physics.atRestY() -> [-1, 0, 1]\n#### physics.atRestZ() -> [-1, 0, 1]\n\nDescribes each of the **local** axises and whether or not the object is resting in that **local** axis (and in what direction).\n\n#### physics.acceleration -> THREE.Vector3\n\nThe avatar's current acceleration in local space (or change in velocity over a frame).\n\n#### physics.velocity -> THREE.Vector3\n\nThe avatar's current velocity in local space (or change in position over a frame).\n\n#### physics.friction -> THREE.Vector3\n\nThe degree by which to scale velocity on each axis for a given frame. Reset to `1.0` during\n`physics.tick(dt)` before the collisions for this frame are calculated and applied. Colliding\nobjects may change the object's friction in any one of the axises during their `collide` call.\n\n#### physics.tick(dt)\n\nCalled by `voxel-engine`.\n\nFor each axis, acceleration is calculated (`accel/8 + forces.x`); acceleration is applied to\nvelocity (`(velocity + accel) / friction`), and a desired local vector is created from velocity\n(`vel > terminal ? terminal : val`).\n\nThen a world desired vector is created from that local desired vector. Friction is reset to `1.0`.\nResting state for all axis is reset to `0`. Then, the potential collision set is iterated, and those\ncalls receive the physics object, the world desired vector, the current bounding box, and the current resting state, and are **expected to modify these variables when there is a collision** (i.e., when we\ncollide with terrain, the friction is modified on opposite axes from the collision; we set the resting\nstate of the object on the colliding axis to the \"direction\" of impact, and we modify the desired world vector to implement the collision).\n\n\n### tiny tips\n\n* Don't modify `physics.avatar.position` directly! Prefer to modify the `acceleration` or `velocity` -- this gives you much more realistic looking motion.\n\n* Remember, all of the force/accel/velocity/friction/resting states are **in local space**, not world space. Collisions happen in **world space**. You have to translate back to **local space** to apply changes.\n\nAs a concrete example, the voxel avatar's player is governed by a physics object attached to the `yaw` (the rotation around the Y axis -- looking left and right). So, our physics attributes look like this:\n\n````\nlocal space                 world space\n                             \n      -z                      -lz    +lx \n      ^                         \\  /\n      |                          \\/\n-x <-----> +x                    /\\\n      |                         /  \\\n      V                      -lx    +lz \n      +z\n````\n\nWhich is to say, the rotation of `yaw` affects the world vectors described by the local physical attributes of your player!\n\n* Use `voxel-control` to implement AI/etc. Instead of describing motion in terms of movements, you can\ndescribe motion in terms of `state.forward = true`, etc, over several frames.\n\n# LICENSE\n\nMIT\n",
  "readmeFilename": "README.md",
  "bugs": {
    "url": "https://github.com/chrisdickinson/voxel-physical/issues"
  },
  "_id": "voxel-physical@0.0.10",
  "dist": {
    "shasum": "19ace984b0fca649c7d042d015edb8c18c16c8b7"
  },
  "_from": "voxel-physical@0.0.10",
  "_resolved": "https://registry.npmjs.org/voxel-physical/-/voxel-physical-0.0.10.tgz"
}
